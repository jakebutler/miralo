#!/usr/bin/env node
import { spawn } from "node:child_process";
import { mkdir, rename } from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";
import { chromium } from "playwright";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const repoRoot = path.resolve(scriptDir, "../..");
const outputDir = path.resolve(repoRoot, "miralo/runtime/recordings");
const port = Number.parseInt(process.env.MIRALO_PORT || "3002", 10);
const baseUrl = `http://127.0.0.1:${port}`;
const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
const screenshotPath = path.join(outputDir, `clickthrough-${timestamp}.png`);
const finalVideoPath = path.join(outputDir, `clickthrough-${timestamp}.webm`);

let server;

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function waitForServer(url, timeoutMs = 90_000) {
  const start = Date.now();

  while (Date.now() - start < timeoutMs) {
    try {
      const res = await fetch(`${url}/demo`, { method: "GET" });
      if (res.ok) {
        return;
      }
    } catch {
      // Server not ready yet.
    }

    await sleep(500);
  }

  throw new Error(`Server did not become ready within ${timeoutMs}ms at ${url}`);
}

function startServer() {
  server = spawn("bun", ["run", "dev", "--", "-p", String(port)], {
    cwd: repoRoot,
    env: { ...process.env, PORT: String(port) },
    stdio: "inherit",
  });

  server.on("exit", (code) => {
    if (code !== 0) {
      console.error(`Dev server exited with code ${code}`);
    }
  });
}

async function runClickthrough() {
  await mkdir(outputDir, { recursive: true });

  startServer();
  await waitForServer(baseUrl);

  const browser = await chromium.launch({ headless: true });
  const context = await browser.newContext({
    viewport: { width: 1366, height: 768 },
    recordVideo: {
      dir: outputDir,
      size: { width: 1366, height: 768 },
    },
  });

  const page = await context.newPage();

  await page.goto(`${baseUrl}/demo`, { waitUntil: "networkidle" });
  await page.fill('[data-testid="todo-input"]', "Prepare demo storyboard");
  await page.click('[data-testid="add-todo-button"]');
  await page.fill('[data-testid="todo-input"]', "Record before/after reveal");
  await page.click('[data-testid="add-todo-button"]');

  await page.click('[data-testid="todo-text-0"]');
  await page.waitForTimeout(400);
  await page.click('[data-testid="delete-todo-1"]');
  await page.waitForTimeout(400);

  await page.screenshot({ path: screenshotPath, fullPage: true });

  const pageVideo = page.video();
  await page.close();
  await context.close();
  await browser.close();

  if (!pageVideo) {
    throw new Error("No video was generated by Playwright.");
  }

  const sourceVideoPath = await pageVideo.path();
  await rename(sourceVideoPath, finalVideoPath);

  console.log("READY_TO_SHOW");
  console.log(`video=${finalVideoPath}`);
  console.log(`screenshot=${screenshotPath}`);
}

async function cleanup() {
  if (server && !server.killed) {
    server.kill("SIGTERM");
    await sleep(800);
    if (!server.killed) {
      server.kill("SIGKILL");
    }
  }
}

try {
  await runClickthrough();
} catch (error) {
  console.error(error instanceof Error ? error.message : error);
  process.exitCode = 1;
} finally {
  await cleanup();
}
